import { exec } from "child_process";
import fs from "fs";
import path from "path";
import { promisify } from "util";

// TODO: Add transactional behavior to this script
/**
 * This script automates the process of releasing a new version of a project using Git and npm.
 *
 * - It validates the version type (major, minor, or patch).
 * - Builds the project and stages the relevant CSS file.
 * - Increments the version number in `package.json` (and optionally `package-lock.json`).
 * - Updates download link in documentation and readme.
 * - Commits the changes with a generated or custom message.
 * - Creates a Git tag for the new version.
 * - Pushes the commit and tag to the remote repository.
 *
 * Usage:
 *   node <path/to/script.js> [versionType] [customMessage]
 *
 * Parameters:
 *   - versionType: "major", "minor", or "patch" (default is "patch").
 *   - customMessage: Custom commit message (optional).
 */

const execAsync = promisify(exec);

async function execShellCommand(cmd) {
  try {
    const { stdout } = await execAsync(cmd);
    return stdout;
  } catch (error) {
    console.error("Execution error:", error);
    throw error.stderr;
  }
}

async function releaseNewVersion(versionType = "patch", customMessage = "") {
  try {
    const validTypes = ["major", "minor", "patch"];
    if (!validTypes.includes(versionType)) {
      throw new Error(
        `Invalid version type specified: ${versionType}. Use major, minor, or patch.`
      );
    }

    await execShellCommand("npm run build");
    await execShellCommand("git add dist/\*");
    const packageJsonPath = path.join(process.cwd(), "package.json");
    const packageLockJsonPath = path.join(process.cwd(), "package-lock.json");
    const readmePath = path.join(process.cwd(), "README.md");
    const documentationContext = path.join(
      process.cwd(),
      "src/",
      "libraryInfo.json"
    );

    const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, "utf8"));
    const versionParts = packageJson.version
      .split(".")
      .map((x) => parseInt(x, 10));

    switch (versionType) {
      case "major":
        versionParts[0] += 1;
        versionParts[1] = 0;
        versionParts[2] = 0;
        break;
      case "minor":
        versionParts[1] += 1;
        versionParts[2] = 0;
        break;
      case "patch":
        versionParts[2] += 1;
        break;
    }

    packageJson.version = versionParts.join(".");

    fs.writeFileSync(packageJsonPath, JSON.stringify(packageJson, null, 2));
    if (fs.existsSync(packageLockJsonPath)) {
      const packageLockJson = JSON.parse(
        fs.readFileSync(packageLockJsonPath, "utf8")
      );
      packageLockJson.version = packageJson.version;
      fs.writeFileSync(
        packageLockJsonPath,
        JSON.stringify(packageLockJson, null, 2)
      );
    }
    const readmeContent = fs.readFileSync(readmePath, "utf8");
    const updatedReadmeContent = readmeContent.replace(
      /markup-refine-lib@\d+\.\d+\.\d+/g,
      `markup-refine-lib@${packageJson.version}`
    );
    fs.writeFileSync(readmePath, updatedReadmeContent);

    const documentationContent = fs.readFileSync(documentationContext, "utf8");
    const updatedDocumentationContent = documentationContent.replaceAll(
      /markup-refine-lib@\d+\.\d+\.\d+/g,
      `markup-refine-lib@${packageJson.version}`
    );
    fs.writeFileSync(documentationContext, updatedDocumentationContent);

    const commitMessage = `
    Release ${versionType} version v${packageJson.version}
    
    Details:
    - Version Type: ${versionType}
    - New Version: v${packageJson.version}
    - Date: ${new Date().toLocaleString()}
    ${customMessage ? `- Notes: ${customMessage}` : ""}
    
    Generated by release script.
    `.trim();

    await execShellCommand(`git commit -am "${commitMessage}"`);

    await execShellCommand(`git tag v${packageJson.version}`);

    await execShellCommand("git push origin main --tags");

    console.log("Version released successfully:", packageJson.version);
  } catch (error) {
    console.error("Failed to release version:", error);
  }
  try {
    await execShellCommand("npm run astro:build");
    await execShellCommand("git add docs/\*");
    await execShellCommand(
      `git commit -am "docs: update docs for the new version"`
    );
    await execShellCommand("git push origin main");
  } catch (error) {
    console.error("Failed to generate the docs:", error);
  }
}

const [, , versionType, customMessage] = process.argv;

releaseNewVersion(versionType, customMessage);
